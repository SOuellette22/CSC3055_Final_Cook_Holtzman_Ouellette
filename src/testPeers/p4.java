package testPeers;

import common.I2P.IDs.Destination;
import common.I2P.NetworkDB.Lease;
import common.I2P.NetworkDB.LeaseSet;
import common.I2P.router.Router;
import common.Logger;
import common.transport.I2CP.*;
import merrimackutil.json.types.JSONObject;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.util.encoders.Base64;

import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.security.*;
import java.util.ArrayList;
import java.util.Scanner;

public class p4 {
    static int routerPort = 10004;
    static int servicePort = 20004;
    static InetSocketAddress bootstrapPeer = new InetSocketAddress("127.0.0.1", 8080);

    public static void main(String[] args) throws IOException {
        Security.addProvider(new BouncyCastleProvider());
        Logger log = Logger.getInstance();
        log.setMinLevel(Logger.Level.DEBUG);
        Thread router = new Thread(new Router(InetAddress.getLoopbackAddress(),routerPort, servicePort, bootstrapPeer));
        router.start();
        if (true) {
            return;
        }
        try {
            Thread.sleep(20000); //wait until router setup
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        KeyPair destEd25519Key = generateKeyPairEd();
        KeyPair destElgamalKey = generateKeyPairElGamal();

        Destination clientDest = new Destination(destEd25519Key.getPublic());

        //do client stuff
        I2CPSocket socket = new I2CPSocket("127.0.0.1", servicePort);
        socket.sendMessage(new CreateSession(clientDest));

        I2CPMessage recvMessage;
        recvMessage = socket.getMessage();

        if (recvMessage.getType() != I2CPMessageTypes.SESSIONSTATUS) {
            System.err.println("bad type: " + recvMessage.getType());
            System.err.println(recvMessage.toJSONType().getFormattedJSON());
            return;
        }
        SessionStatus sessionStatus = (SessionStatus) recvMessage;

        if (sessionStatus.getStatus() != SessionStatus.Status.CREATED) {
            System.err.println("could not create session " + sessionStatus.getStatus());
            return;
        }

        //IMPORTANT NOTE this is the session ID since it is generated by the router
        int sessionID = sessionStatus.getSessionID();
        recvMessage = socket.getMessage();

        if (recvMessage.getType() != I2CPMessageTypes.REQUESTLEASESET) {
            System.err.println("Bad type " + recvMessage.getType());
            System.err.println(recvMessage.toJSONType().getFormattedJSON());
        }

        RequestLeaseSet requestLeaseSet = (RequestLeaseSet) recvMessage;
        ArrayList<Lease> leases = new ArrayList<>();
        leases.addAll(requestLeaseSet.getLeases());

        LeaseSet leaseSet = new LeaseSet(leases, clientDest, destElgamalKey.getPublic(), destEd25519Key.getPrivate());

        socket.sendMessage(new CreateLeaseSet(sessionID, destElgamalKey.getPrivate(), leaseSet));

        //basic testing loop
        Scanner input = new Scanner(System.in);
        Destination currDest = null;

        while(true) {
            System.out.println("You are client for dest: " + Base64.toBase64String(clientDest.getHash()));
            System.out.println("Press 1 to lookup destination");
            System.out.println("Press 2 to send message to ");
            System.out.println();
            int usercase = input.nextInt();
            input.nextLine();
            switch(usercase) {
                case 1 -> {
                    try {
                        System.out.print("Please enter destination hash: ");
                        String hash = input.nextLine();
                        byte[] destKey = Base64.decode(hash);
                        socket.sendMessage(new DestinationLookup(sessionID, destKey));
                        recvMessage = socket.getMessage();
                        System.out.println("Got message from router");
                        DestinationReply reply = (DestinationReply) recvMessage;
                        if (reply.getDestination() != null) {
                            currDest = reply.getDestination();
                            System.out.println("Got destination! " + currDest);
                            System.out.println("You can now send there!");
                        }
                        else {
                            System.out.println("Destination not found :(");
                        }
                    }
                    catch (Exception e) {
                        Logger.getInstance().error("error " ,e );
                    }
                }
                case 2 -> {
                    if (currDest == null) {
                        System.out.println("please lookup destination first");
                        continue;
                    }
                    JSONObject obj = new JSONObject();
                    obj.put("To:", Base64.toBase64String(currDest.getHash()));
                    obj.put("Message", "You will find moonlit nights stangley empty");
                    obj.put("From: ", Base64.toBase64String(clientDest.getHash()));

                    socket.sendMessage(new SendMessage(sessionID, currDest, new byte[4], obj));
                }
                default -> {
                    System.out.println("bad input gurrr ");
                }
            }
        }


    }

    /*
     * stolen from sam router class
     */
    private static KeyPair generateKeyPairEd() {
        // Generate a key pair for the router
        try {
            KeyPairGenerator keyGen = KeyPairGenerator.getInstance("Ed25519", "BC");
            return keyGen.generateKeyPair();
        } catch (NoSuchAlgorithmException | NoSuchProviderException e) {
            throw new RuntimeException(e); // should never hit case
        }
    }

    private static KeyPair generateKeyPairElGamal() {
        // Generate a key pair for the router
        try {
            KeyPairGenerator keyGen = KeyPairGenerator.getInstance("ElGamal");
            keyGen.initialize(2048); // 2048 bits for RSA
            return keyGen.generateKeyPair();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }
}

